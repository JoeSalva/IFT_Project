<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Building Walkthrough</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #dcdcdc;
      touch-action: none;
    }

    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: sans-serif;
      background: rgba(0, 0, 0, 0.6);
      padding: 20px 30px;
      border-radius: 8px;
      cursor: pointer;
      z-index: 100;
    }

    #buttons {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
    }

    button {
      margin: 4px;
      padding: 6px 12px;
      border: none;
      background: #4a4a4a;
      color: white;
      border-radius: 6px;
      cursor: pointer;
    }

    button:hover {
      background: #6b6b6b;
    }

    #joystick-zone {
      position: absolute;
      bottom: 50px;
      left: 50px;
      width: 120px;
      height: 120px;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div id="instructions">
    ðŸ•¹ Click to Start Walkthrough<br />
    Use W, A, S, D to move<br />
    Move mouse or swipe to look around
  </div>

  <div id="buttons">
    <button onclick="loadModel('hostelA')">Hostel A</button>
    <button onclick="loadModel('hostelC')">Hostel C</button>
    <button onclick="loadModel('ICT')">ICT</button>
    <button onclick="loadModel('new_library')">New Library</button>
    <button onclick="loadModel('old_library')">Old Library</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.157.0";
  import { PointerLockControls } from "https://esm.sh/three@0.157.0/examples/jsm/controls/PointerLockControls.js";
  import { GLTFLoader } from "https://esm.sh/three@0.157.0/examples/jsm/loaders/GLTFLoader.js";

  let scene, camera, renderer, controls, currentModel = null;
  const groundLevel = -5;
  const playerHeight = 1.3;
  let joystick = null;
  const joystickData = { active: false, vx: 0, vy: 0 };
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

  // Mobile look control
  let isTouching = false, lastTouchX = 0, lastTouchY = 0;

  const modelConfigs = {
    hostelA: { path: "models/hostelA.glb", rotationY: Math.PI / 4, cameraOffset: new THREE.Vector3(-9, 1.0, 4) },
    hostelC: { path: "models/hostelC.glb", rotationY: Math.PI / 2, cameraOffset: new THREE.Vector3(-1, 1.0, 8) },
    ICT: { path: "models/ICT.glb", rotationY: Math.PI, cameraOffset: new THREE.Vector3(0, 1.5, 5) },
    new_library: { path: "models/new_library.glb", rotationY: 0, cameraOffset: new THREE.Vector3(0, 1.0, 5) },
    old_library: { path: "models/old_library.glb", rotationY: 0, cameraOffset: new THREE.Vector3(5, 1.0, 0), yOffset: 1 },
  };

  const keys = { w: false, a: false, s: false, d: false };

  document.addEventListener("keydown", e => {
    const key = e.key.toLowerCase();
    if (keys.hasOwnProperty(key)) keys[key] = true;
  });
  document.addEventListener("keyup", e => {
    const key = e.key.toLowerCase();
    if (keys.hasOwnProperty(key)) keys[key] = false;
  });

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfd1e5);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 10, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(400, 400),
      new THREE.MeshStandardMaterial({ color: 0x999999 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = groundLevel;
    ground.receiveShadow = true;
    scene.add(ground);

    controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());
    controls.getObject().position.set(0, playerHeight, 5);

    const instructions = document.getElementById("instructions");

    if (!isMobile) {
      instructions.addEventListener("click", () => controls.lock());
      controls.addEventListener("lock", () => (instructions.style.display = "none"));
      controls.addEventListener("unlock", () => (instructions.style.display = ""));
    } else {
      instructions.style.display = "none";
      setupJoystick();
      setupFullScreenLook();
    }

    window.addEventListener("resize", onWindowResize);

    const params = new URLSearchParams(window.location.search);
    const modelName = params.get("model");
    if (modelName && modelConfigs[modelName]) loadModel(modelName);
  }

  // âœ… Joystick setup
  function setupJoystick() {
    const zone = document.createElement("div");
    zone.id = "joystick-zone";
    document.body.appendChild(zone);

    joystick = nipplejs.create({
      zone,
      mode: "static",
      position: { left: "70px", bottom: "70px" },
      color: "white",
    });

    joystick.on("move", (evt, data) => {
      joystickData.active = true;
      joystickData.vx = data.vector ? data.vector.x : 0;
      joystickData.vy = data.vector ? data.vector.y : 0;
    });

    joystick.on("end", () => {
      joystickData.active = false;
      joystickData.vx = 0;
      joystickData.vy = 0;
    });
  }

  // âœ… Full-screen swipe look
 // âœ… Improved full-screen swipe look (mobile)
  function setupFullScreenLook() {
    let touchStartX = 0, touchStartY = 0;
    let yaw = 0;   // horizontal rotation (left/right)
    let pitch = 0; // vertical rotation (up/down)

    // Start by matching existing camera rotation
    yaw = controls.getObject().rotation.y;
    pitch = camera.rotation.x;

    renderer.domElement.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        isTouching = true;
        touchStartX = e.touches[0].pageX;
        touchStartY = e.touches[0].pageY;
      }
    });

    renderer.domElement.addEventListener("touchmove", (e) => {
      if (!isTouching) return;

      const touch = e.touches[0];
      const dx = touch.pageX - touchStartX;
      const dy = touch.pageY - touchStartY;
      touchStartX = touch.pageX;
      touchStartY = touch.pageY;

      const lookSpeed = 0.003; // sensitivity

      // Update rotation values
      yaw -= dx * lookSpeed;
      pitch -= dy * lookSpeed;

      // âœ… Clamp pitch to prevent flipping
      const maxPitch = Math.PI / 2 - 0.05;
      const minPitch = -Math.PI / 2 + 0.05;
      pitch = Math.max(minPitch, Math.min(maxPitch, pitch));

      // Apply rotation
      controls.getObject().rotation.y = yaw;
      camera.rotation.x = pitch;
    });

    renderer.domElement.addEventListener("touchend", () => {
      isTouching = false;
    });
  }


  function loadModel(name) {
    const config = modelConfigs[name];
    if (!config) return console.error(`No config for ${name}`);

    const loader = new GLTFLoader();
    if (currentModel) scene.remove(currentModel);

    loader.load(
      config.path,
      (gltf) => {
        const model = gltf.scene;
        model.rotation.y = config.rotationY || 0;

        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);
        model.position.y = -1;

        if (config.yOffset !== undefined) model.position.y += config.yOffset;

        scene.add(model);
        currentModel = model;

        controls.getObject().position.copy(config.cameraOffset);
        controls.getObject().position.y = config.cameraOffset.y || playerHeight;

        const target = new THREE.Vector3();
        model.getWorldPosition(target);
        target.y += 1.5;
        controls.getObject().lookAt(target);
      },
      undefined,
      (err) => console.error(`Error loading ${config.path}:`, err)
    );
  }

  function movePlayer() {
    const moveSpeed = 0.1;
    const frontVector = new THREE.Vector3();
    const sideVector = new THREE.Vector3();
    const direction = new THREE.Vector3();

    camera.getWorldDirection(frontVector);
    frontVector.y = 0;
    frontVector.normalize();
    sideVector.crossVectors(frontVector, camera.up).normalize();

    if (keys.w) direction.add(frontVector);
    if (keys.s) direction.sub(frontVector);
    if (keys.a) direction.sub(sideVector);
    if (keys.d) direction.add(sideVector);

    if (joystickData.active) {
      const forwardMove = frontVector.clone().multiplyScalar(joystickData.vy * 0.5);
      const rightMove = sideVector.clone().multiplyScalar(joystickData.vx * 0.5);
      direction.add(forwardMove);
      direction.add(rightMove);
    }

    if (direction.lengthSq() > 0) {
      direction.normalize();
      controls.getObject().position.addScaledVector(direction, moveSpeed);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    movePlayer();
    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  window.loadModel = loadModel;
  </script>
</html>